# Лабораторна робота 1

## Принципи, дотримані в рамках лабораторної роботи:

### KISS (Keep It Simple, Stupid)
Код написано просто та зрозуміло. Кожен клас виконує лише одну конкретну задачу:
- Клас `Product` відповідає за збереження даних про товар.
- Клас `Warehouse` займається управлінням запасами товарів.
- Клас `Reporting` генерує звіти і реєструє надходження та відвантаження товарів.
- Клас `Money` обробляє цінову інформацію про товари.

### YAGNI (You Aren't Going to Need It)
У коді немає зайвого функціоналу або непотрібних функцій. Усі методи реалізовані тільки для вирішення задач, описаних у лабораторній роботі, без додавання непотрібних опцій чи складнощів.

### DRY (Don't Repeat Yourself)
Вся логіка, яка повторюється в програмі, була винесена в окремі методи. Наприклад, додавання товару або зміна кількості товару зберігається лише в одному місці, що дозволяє зменшити дублювання коду.

### Fail Fast
У класі `Reporting` при реєстрації відвантаження товару перевіряється, чи є достатньо товару в складі, і виводиться повідомлення про помилку, якщо кількість товару менша за необхідну.

**Посилання на код:** [Reporting.cs](https://github.com/Oleg-Ischuk/KPZ-course2/blob/Lab-1/Lab-1/Library/Reporting.cs#L24-L46)

### Composition Over Inheritance
У класі `Reporting` використовується композиція для роботи з класом `Warehouse`. Це дозволяє уникнути надмірної складності та дає більшу гнучкість при зміні логіки роботи складу.

**Посилання на код:** [Reporting.cs](https://github.com/Oleg-Ischuk/KPZ-course2/blob/Lab-1/Lab-1/Library/Reporting.cs#L11-L16)

### SOLID (S - Single Responsibility Principle)
Кожен клас у програмі відповідає лише за одну задачу:
- Клас `Product` відповідає за інформацію про товар.
- Клас `Warehouse` відповідає за управління запасами.
- Клас `Reporting` відповідає за створення звітів і реєстрацію надходжень/відвантажень.
- Клас `Money` відповідає за роботу з ціною товарів.

**Посилання на код:** [Product.cs](https://github.com/Oleg-Ischuk/KPZ-course2/blob/Lab-1/Lab-1/Library/Product.cs)

### SOLID (O - Open/Closed Principle)
Програма розроблена таким чином, що існуючий код можна легко розширювати новими методами або класами без зміни існуючої логіки.

### SOLID (L - Liskov Substitution Principle)
У класах не використовується жодна ситуація, яка порушувала б принцип підстановки Лісков. Програма не містить класів, які є підкласами для інших, тому це не створює проблем у підстановці.

### SOLID (I - Interface Segregation Principle)
Програма не використовує інтерфейси без потреби, так як усі класи виконують свої функції без додаткових абстракцій.

### SOLID (D - Dependency Inversion Principle)
Програма не використовує абстракцію. 

